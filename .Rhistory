# Clear the variables
rm(list = ls())
# Set the working directory to source file location with
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Install packages
packages <- c("tidyverse", "rsdmx", "eurostat", "tbl2xts",
"tidyquant", "BCDating", "pwt10", "dplyr",
"stargazer", "car", "forecast", "tseries", "quantmod", "eurostat")
new.packages <- packages[!(packages %in% installed.packages()[, "Package"])]
if (length(new.packages)) install.packages(new.packages)
invisible(lapply(packages, library, character.only = TRUE))
# Load packages
library(quantmod)
library(eurostat)
# 1 - Data generating process
# Simulate an AR(i), a MA(i) and an ARMA(i,j) study the correlogram,
# where you must choose i and j as
# positive integers, while the parameters can be positive or negative
# sampling for value for i and j
i <- 1
j <- 2
# generate a random series
y <- rnorm(100)
# compute AR(i) of y
ar.i <- ar(y, i)
# prediction of AR(i)
pred.ar.i <- ts(predict(ar.i, h = 12))
# plot the prediction of AR(i) and the original data
plot(y, type = "l", col = "blue", lwd = 2, xlab = "Time", ylab = "Log PCEC")
lines(pred.ar.i, type = "l", col = "red", lwd = 2, lty = 2)
# compute MA(i) of y
ma.i <- ma(y, i)
# compute ARMA(i,j) of y
arma.ij <- arma(x = y, order = c(i, j))
# plot the AR(i)
plot(ar.i)
# plot the MA(i)
plot(ma.i)
# plot the ARMA(i,j)
plot(arma.ij)
# compute the autocorrelation function of the MA(i)
acf.ma.i <- acf(ma.i)
# compute the autocorrelation function of the ARMA(i,j)
acf.arma.ij <- acf(arma.ij)
# 4 - Plot the autocorrelation function of the three models
# plot the autocorrelation function of the AR(i)
plot(acf.ar.i)
# plot the autocorrelation function of the MA(i)
plot(acf.ma.i)
# plot the autocorrelation function of the ARMA(i,j)
plot(acf.arma.ij)
?yule-walker
package(urca)
library(urca)
?arima
?list
?table
?list
knitr::opts_chunk$set(echo = TRUE)
ac<-acf(y, lag.max = 10, plot = FALSE)
?ac
######## Random Walk
set.seed(123)
sim.num<-1000
# Use arima.sim() to generate WN data
white_noise <- arima.sim(model = list(order = c(0, 0, 0)), n = sim.num)
# Use cumsum() to convert your WN data to RW
random_walk <- cumsum(white_noise)
# Use arima.sim() to generate WN drift data
wn_drift <- arima.sim(model = list(order = c(0, 0, 0)), n = sim.num, mean = 0.4)
# Use cumsum() to convert your WN drift data to RW
rw_drift <- cumsum(wn_drift)
# Plot all four data objects
plot.ts(cbind(white_noise, random_walk, wn_drift, rw_drift))
# Use arima.sim() to generate WN drift data
wn_drift <- arima.sim(model = list(order = c(0, 0, 0)), n = sim.num, mean = 0.4)
# Plot all four data objects
plot.ts(cbind(white_noise, random_walk, wn_drift, rw_drift))
###################################################################
# Simulate an ARMA(1,1)
###############################################################
set.seed(123)
y.ARMA.11 <- arima.sim(model = list(ar = c(0.3),ma = c(0.5)), n = 200)
y<-y.ARMA.11
par(mfrow=c(3,1),mar = c(2, 2, 3, 2))
layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE))
ts.plot(y,main='ARMA(1,1)')
#acf(y,lag.max=15, main='Autocorrelation')
plot(acf(y,plot=F)[1:15],main='ACF')
pacf(y,lag.max=15,main="PACF")
?Nan
?
?is.nan
?
?is.nan
?||
||
knitr::opts_chunk$set(echo = TRUE)
library(tsm)
bn.decomp <- bnd(GDP, nlag=2)  # apply the BN decomposition that creates data.frame
? se
? se
?se
?std.error()
?arima.fit
